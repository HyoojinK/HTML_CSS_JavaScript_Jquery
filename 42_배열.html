<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //   let arr = new Array(10, 20, 30, "김효진", 3.14, true);   // 배열객체생성
      let arr = [10, 20, 30, "김효진", 3.14, "홍길동", false, ["a", "b", "c"]]; // 객체리터럴
      for (let i = 0; i < arr.length; i++) {
        document.write(arr[i] + "<br>");
      }

      let arr1 = [
        [10, 20, 30],
        ["kim", "park", "hong"],
      ];
      for (let i = 0; i < arr1.length; i++) {
        for (let j = 0; j < arr1[i].length; j++) {
          document.write(arr1[i][j] + " ");
        }
        document.write("<br>");
      }

      // 배열.toString() : 배열값을 콤마로 구분된 문자열로 반환함
      let fruits = ["바나나", "오렌지", "사과", "망고", "레몬"];
      document.write(fruits.toString());
      document.write("<br>");

      //   배열.join() : 배열값을 제시된 문자로 연결하여 하나의 문자열로 만들어서 출력함
      document.write(fruits.join(" and ") + "<br>");

      // 배열.push() : 배열의 마지막요소 추가
      // 배열.unshift() : 배열의 첫번째요소 추가
      // 배열.pop() : 배열의 마지막요소 삭제
      // 배열.shift() : 배열의 첫번째요소 삭제
      fruits.push("파인애플");
      fruits.unshift("자두");
      document.write(fruits.toString() + "<br>");
      fruits.pop();
      document.write(fruits.toString() + "<br>");

      //   배열.splice(위치번호, 삭제갯수, 값):배열의 지정된 위치의 요소를 추가, 삭제, 수정할 수 있음
      let alphabet = ["a", "b", "c", "f"];
      // 3번 위치에 'd'를 추가하시오.
      alphabet.splice(3, 0, "d");
      document.write(alphabet.toString() + "<br>"); //['a', 'b', 'c', 'd', 'f']
      // 4번 위치의 'f'를 'e'로 수정하시오.
      alphabet.splice(4, 1, "e");
      document.write(alphabet.toString() + "<br>");
      // 0번 위치의 'a'를 삭제하시오.
      alphabet.splice(0, 1);
      document.write(alphabet.toString() + "<br>");

      // 배열.indexOf('찾는문자열') : 찾는 값이 없으면 -1 값이 구해짐
      // 'c'요소를 찾아서 'kim'으로 수정하시오.
      alphabet.splice(alphabet.indexOf("c"), 1, "kim");
      document.write(alphabet.toString() + "<br>");
      // 'd'요소를 찾아서 삭제하시오.
      alphabet.splice(alphabet.indexOf("d"), 1);
      document.write(alphabet.toString() + "<br>");

      // 배열.slice(시작인덱스, 끝인덱스+1) :배열을 추출해서 새로운 배열 생성(기존 배열은 그대로 유지됨)
      let num = [300, 100, 400, 500, 200];
      document.write(num.toString() + "<br>");
      let newnum = num.slice(1, 4);
      document.write(newnum.toString() + "<br>");
      let newnum1 = num.slice(1); // 1번부터 끝까지 추출
      document.write(newnum1.toString() + "<br>");

      // 배열.reverse() : 배열을 역순으로 정렬
      num.reverse();
      document.write(num.toString() + "<br>");

      // 배열.sort() : 배열요소들을 내림차순 또는 오름차순으로 정렬
      function compare(a, b) {
        return a - b; // 내림차순(b-a), 오름차순(a-b)
      }
      num.sort(compare);
      document.write(num.toString() + "<br>");

      // 배열1.concat(배열2) : 배열1과 배열2를 합쳐 새로운 배열 한개로
      let numalphabet = num.concat(alphabet);
      document.write(numalphabet.toString() + "<br>");
      document.write(num.toString() + "<br>");
      document.write(alphabet.toString() + "<br>");

      // 배열.map(function(vlaue, index){}) : 배열요소를 순차적으로 접근함

      /*
             num.map(function (value, index) {
             document.write(value + "," + index + "<br>");
             });
         */
      num.map((value, index) => document.write(value + "," + index + "<br>"));
      // 일반함수를 화살표함수로 쓸 때 'function'이라는 단어 지우고 ()와 {} 사이에 '=>' 삽입하면 됨 (함수, 매개변수가 하나일경우에는 괄호 생략 가능)

      /*
             let multiplynum = num.map(function (value, index) {
             return value * 2;
             });
          */
      let multiplynum = num.map((value, index) => value * 2);

      document.write(multiplynum.toString() + "<br>");
      document.write(num.toString() + "<br>");

      // 배열.forEach(function(value, index){}) : map()은 return문을 사용하여 새로운 배열을 생성할 수 있지만, forEach()는 return문을 사용할 수 없음.
      num.forEach((value, index) => {
        value += 1;
        document.write(`${index + 1}. ${value}<br>`);
      });
      document.write(num.toString() + "<br>");

      // 배열.filter(function(value, index){retrun}) : 조건에 맞는 값들을 필터링해서 return문으로 새로운 배열을 생성함
      let people = arr.filter((value, index) => {
        let kind = typeof value; // number, String, object, boolean
        return kind === "string";
      });
      document.write(people.toString() + "<br>");
    </script>
  </body>
</html>
